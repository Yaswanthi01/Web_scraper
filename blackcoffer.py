# -*- coding: utf-8 -*-
"""BlackCoffer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dCuhiT5ebToD-P5pDhyBZwDd1iKwDdaG

## **Importing Necessary Libraries**
"""

import openpyxl                                                                 
import requests                                                                 
from bs4 import BeautifulSoup
import nltk
from nltk.corpus import stopwords
nltk.download('stopwords')
nltk.download('punkt')
import csv

"""## **EXTRACTING TEXT FROM URL**"""

wb = openpyxl.load_workbook('Input.xlsx')               #Accessing the xlsx file
ws = wb['Sheet1']

ls=[]                                                   #Nested loop of URL_ID and URL
r=2
for i in range(20):
  ls.append([])
  c=1
  for j in range(2):
    ls[i].append(ws.cell(row = r,column = c).value)
    c+=1
  r+=1

"""## **DATA EXTRACTION**"""

def url_text(URL):
  headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:55.0) Gecko/20100101 Firefox/55.0',}
  page = requests.get(URL,headers=headers)
  soup = BeautifulSoup(page.content, "html.parser")
  result=""
  for data in soup.find_all("p"):
    result += data.get_text()                           #Extracting all text from URL "excluding header and footer"
  return result
print(len(ls))
for i in range(len(ls)):
  URL_ID=int(ls[i][0])
  URL=ls[i][1]

  res = url_text(URL)
  s=str(URL_ID)
  f = open(s,"w",encoding="utf-8")                                       #Creating file as their URL_ID

  for line in res:
    f.write(line)                                       #Writing all text from URL to their URL_ID named file

  f.close()

"""## **DATA ANALYSIS**"""

positive_txt = []                                        #List of positive words
negative_txt = []                                        #List of negative word
out_row = []                                             #List of output rows

new_wb = openpyxl.load_workbook('LoughranMcDonald_MasterDictionary_2021.xlsx')  
new_ws = new_wb['Loughran-McDonald_MasterDiction']

"""**All fields of Output sheet**




"""

fields = ["URL_ID", "URL", "Positive_Score", "Negative_Score", "Polarity_Score", "Subjectivity_Score", "Avg_Sentence_Length", "Percentage_of_Complex_Words", "Fog_Index", "Avg_Number_of_Words_Per_Sentence", "Complex_Word_Count", "Word_Count", "Syllable_Per_Word", "Personal_Pronouns", "Avg_Word_Length"]

for i in range(2,86532):
  
  if(new_ws.cell(row = i,column = 9).value > 0 ):
    positive_txt.append(new_ws.cell(row = i,column = 1).value)
  
  if(new_ws.cell(row = i,column = 8).value > 0):
    negative_txt.append(new_ws.cell(row = i,column = 1).value)

def word_count(words):                                                          #function to filter all text 
  stop_words = set(stopwords.words('english'))
  punctuations = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
  for i in words:
    if i in punctuations:
      i = i.replace(i, "")
  word_tokens = words
  filtered_sentence = [w for w in word_tokens if not w.lower() in stop_words]
  filtered_sentence = []

  for w in word_tokens:
    if w not in stop_words:
      filtered_sentence.append(w)
  return filtered_sentence

def pos_con(word):                                                              #function to check whether word is positive or not
  if word in positive_txt:
    return True
  else:
    return False

def neg_con(word):                                                              #function to check whether word is negaitive or not
  if word in negative_txt:
    return True
  else:
    return False

def polarity_score(a,b):                                                        #function to calculate polarity score 
  p_score= (a-b)/((a+b)+0.000001)
  return p_score

def subjective_score(a,b,c):                                                    #function to calculate subjective score
  s_score = (a+b)/(c+0.000001)
  return s_score

def syllable_count(word):                                                       #function to calculate no of syllabe in word
    word = word.lower()
    count = 0
    vowels = "aeiouy"
    if word[0] in vowels:
        count += 1
    for index in range(1, len(word)):
        if word[index] in vowels and word[index - 1] not in vowels:
            count += 1
    if word.endswith("e") or word.endswith("es") or word.endswith("ed"):        #excluding word endswith " e ", " es " and " ed "
        count -= 1
    if count == 0:
        count += 1
    return count

def complex_count(a):                                                           #function to check whether it is complex or not
  if a > 2:
    return 1
  return 0

def sentence_count(a):                                                          #function to calculate no of sentences
  f=open(str(a),encoding="utf-8")
  raw=f.read()
  tokenized_sentences=nltk.sent_tokenize(raw)
  return len(tokenized_sentences)

def avg_sentence_length(a,b):                                                   #function to calculate average sentence length
  if b==0:
    b=1
  avg_sl = a/b
  return avg_sl

def percentage_complex_word(a,b):                                               #function to calculate percentage of complex words
  pcw = a/b
  return pcw

def fog_index(a,b):                                                             #function to calculate fog index
  fg_index = (a+b)*0.4
  return fg_index

def avg_word_length(a,b):                                                       #function to calculate average word length
  awl=a/b
  return awl

def pron_count(a):                                                              #function to calculate pronoun count
  d=["I","we","my","ours","us"]
  if a in d:
    return 1
  return 0

for i in range(len(ls)):
  positive_con = negative_con = c_words = syl_line = character_length = pronoun_count = 0
  a=int(ls[i][0])
  sr=str(ls[i][1])
  f = open(str(a),encoding="utf-8")         
  x=f.read().split()

  
  for j in x:
    syl_word = 0
    
    p=pos_con(j.upper())
    n=neg_con(j.upper())
    if p == True:
      positive_con +=1                                                          #Count no of positive words
    if n == True:
      negative_con +=1                                                          #Count no of negative words

    syl_word = syllable_count(j)
    syl_line += syl_word                                                        #total syllabe in file
    c_words += complex_count(syl_word)                                          #total complex words in file
    character_length += len(j)                                                  #total no of characters in files
    pronoun_count += pron_count(j)                                              #total no of pronoun in file

  sens_count = sentence_count(a)                                                #count of sentences

  
  x = word_count(x) 
  w_count = len(x)
  if w_count ==0:
    w_count=1                                                              #count of words
  syl_line = syl_line/w_count                                                   #count of syllabes
  p_score = polarity_score(positive_con,negative_con)                           #polarity score
  s_score = subjective_score(positive_con,negative_con,w_count)                 #subjective score
  avg_sent_length = avg_sentence_length(w_count,sens_count)                     #avg sentence length
  percentage_complex = percentage_complex_word(c_words,w_count)                 #percentage of complex words
  fg_index = fog_index(avg_sent_length,percentage_complex)                      #fog index
  avg_nof_words = avg_sent_length                                               #avg no of words per sentence
  avg_wl= avg_word_length(character_length,w_count)                             #avg word length

  output_row = [a,sr,positive_con,negative_con,p_score,s_score,avg_sent_length,percentage_complex,fg_index,avg_nof_words,c_words,w_count,syl_line,pronoun_count,avg_wl]
  out_row.append([output_row])                         #List of output rows


  f.close()

def csv_writer(output_rows):                        #function to create output.csv
  output_file = "Output.csv"
  with open(output_file, "w") as csvfile:
    csvwriter = csv.writer(csvfile) 
    csvwriter.writerow(fields) 
    for i in output_rows:
      csvwriter.writerows(i)                        #write all output row in csv file

csv_writer(out_row)                       #calling function to write in csv file